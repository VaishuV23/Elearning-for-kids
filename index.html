<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Kid Speak &amp; Learn</title>
    <!--
      This page defines a simple single‚Äëpage application for the Kid Speak & Learn
      experience.  The layout borrows visual cues from a modern chat interface
      but is implemented with plain HTML and CSS so it can live alongside the
      existing Firebase/Firestore client logic without requiring a React build
      step.  All identifiers referenced by the accompanying JavaScript are
      preserved (e.g. #chatList, #recordBtn, #textInput) so the original
      behaviour continues to work.
    -->
    <style>
      :root {
        /* Base palette reused from the original application */
        --card:   #fff;
        --ink:    #111;
        --muted:  #666;
        --bd:     #e5e7eb;
        --bg:     #f8fafc;
        --primary:         #111;
        --primary-contrast:#fff;
        --accent:          #f1f5f9;
      }
      * { box-sizing: border-box; }
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: system-ui, Segoe UI, Roboto, Arial;
        background: var(--bg);
        color: var(--ink);
        display: flex;
        flex-direction: column;
      }
      /* Authentication bar at the very top */
      #authBar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: .5rem;
        padding: .6rem 1rem;
        border-bottom: 1px solid var(--bd);
        background: #fff;
        z-index: 10;
      }
      #authBar .user-info {
        display: flex;
        align-items: center;
        gap: .5rem;
      }
      #authBar img {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1px solid var(--bd);
        display: none;
      }
      #authBar .user-name { font-weight: 600; }
      #authBar .user-email { color: var(--muted); font-size: .9rem; }
      /* --- Auth bar pro styles --- */
.auth-actions {
  display: flex;
  gap: .6rem;
  align-items: center;
}

.btn-auth {
  display: inline-flex;
  align-items: center;
  gap: .5rem;
  padding: .55rem .9rem;
  border-radius: 10px;
  border: 1px solid var(--bd);
  background: #fff;
  color: var(--ink);
  font-weight: 600;
  font-size: .9rem;
  line-height: 1;
  cursor: pointer;
  box-shadow: 0 1px 0 rgba(0,0,0,.03);
  transition: transform .06s ease, box-shadow .2s ease, border-color .2s;
}
.btn-auth:hover { box-shadow: 0 4px 14px rgba(0,0,0,.06); }
.btn-auth:active { transform: translateY(1px); }
.btn-auth[disabled] { opacity:.6; cursor:not-allowed; }

/* Brands */
.btn-google      { border-color:#e5e7eb; }
.btn-facebook    { background:#1877F2; color:#fff; border-color:#1877F2; }
.btn-email       { background:#111; color:#fff; border-color:#111; }
.btn-phone       { background:#16a34a; color:#fff; border-color:#16a34a; }

/* Make the auth bar breathe on small screens */
@media (max-width: 640px) {
  #authBar { flex-wrap: wrap; gap:.75rem; }
  .auth-actions { flex-wrap: wrap; width:100%; justify-content: flex-end; }
}

      /* Overall layout */
      .app-container {
        flex: 1;
        display: flex;
        min-height: 0;
        overflow: hidden;
      }
      /* Sidebar area */
      .side {
        width: 280px;
        background: var(--card);
        border-right: 1px solid var(--bd);
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      .side h1 {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 600;
      }
      .side .header {
        padding: 1rem;
        border-bottom: 1px solid var(--bd);
      }
      .side .header .logo {
        display: flex;
        align-items: center;
        gap: .75rem;
        margin-bottom: .75rem;
      }
      .side .header .logo-icon {
        width: 32px;
        height: 32px;
        background: var(--primary);
        color: var(--primary-contrast);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: .9rem;
      }
      /* Language selection card */
      .lang-card {
        cursor: pointer;
        padding: .5rem .75rem;
        background: var(--bg);
        border: 1px solid transparent;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background .15s, border-color .15s;
      }
      .lang-card:hover {
        background: var(--accent);
        border-color: var(--bd);
      }
      .lang-settings {
        margin-top: .75rem;
        padding: .75rem;
        background: var(--bg);
        border: 1px solid var(--bd);
        border-radius: 8px;
      }
      .lang-settings label {
        font-size: .75rem;
        color: var(--muted);
        display: block;
        margin-bottom: .25rem;
      }
      .lang-settings select {
        width: 100%;
        padding: .5rem;
        border: 1px solid var(--bd);
        border-radius: 6px;
        background: #fff;
        font-size: .9rem;
      }
      /* Chat history list */
      .chat-list-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: .5rem;
      }
      .chatitem {
        padding: .6rem .7rem;
        border: 1px solid var(--bd);
        border-radius: 10px;
        background: #fafafa;
        cursor: pointer;
        transition: background .15s, border-color .15s;
      }
      .chatitem:hover {
        background: #f1f5f9;
      }
      .chatitem.active {
        background: #eef2ff;
        border-color: #c7d2fe;
      }
      /* User profile at bottom of sidebar */
      .user-profile {
        padding: 1rem;
        border-top: 1px solid var(--bd);
        display: flex;
        align-items: center;
        gap: .75rem;
      }
      .user-profile .avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: rgba(17, 17, 17, .1);
        color: var(--primary);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: .9rem;
      }
      .user-profile .info {
        flex: 1;
        min-width: 0;
      }
      .user-profile .info .name {
        font-size: .9rem;
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .user-profile .info .email {
        font-size: .75rem;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      /* Main conversation panel */
      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      .status {
        padding: 0.5rem 1rem;
        font-size: .9rem;
        color: var(--muted);
      }
      #loadingBar {
        display: none;
        width: 100%;
        padding: .6rem;
        background: #4CAF50;
        color: #fff;
        text-align: center;
        border-radius: 8px;
        margin: 0 1rem .5rem;
        font-weight: 600;
      }
      #chatThread {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: .75rem;
        background: var(--bg);
        border-top: 1px solid var(--bd);
        border-bottom: 1px solid var(--bd);
      }
      /* Message bubbles */
      .msg {
        max-width: 70%;
        padding: .6rem 1rem;
        border-radius: 16px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        line-height: 1.4;
        word-break: break-word;
        font-size: .95rem;
      }
      .msg.user {
        align-self: flex-end;
        background: linear-gradient(135deg, #dbeafe, #c7d2fe);
        border-top-right-radius: 0;
      }
      .msg.assistant {
        align-self: flex-start;
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        border-top-left-radius: 0;
      }
      /* Markdown formatting for assistant bubbles */
.msg.assistant :is(p, ul, ol, pre, code, blockquote, h1, h2, h3) { margin: .25rem 0; }
.msg.assistant pre { padding: .6rem; border-radius: 8px; overflow:auto; background:#1111/4; }
.msg.assistant code { padding: .1rem .3rem; border-radius: 6px; background:#1111/4; }
.msg.assistant a { color:#0b62ff; text-decoration:none; }
.msg.assistant a:hover { text-decoration:underline; }

      /* Suggestions */
      #suggestions {
        display: none;
        padding: .5rem 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: .5rem;
      }
      .suggestion-btn {
        padding: .4rem .9rem;
        border-radius: 999px;
        background: #f1f5f9;
        border: 1px solid var(--bd);
        cursor: pointer;
        font-size: .85rem;
        transition: background .2s;
      }
      .suggestion-btn:hover { background: #e2e8f0; }
      /* Player */
      #player {
        margin: 0 1rem 1rem;
        width: calc(100% - 2rem);
      }
      /* Input area */
      .input-panel {
        border-top: 1px solid var(--bd);
        padding: 1rem;
      }
      .input-wrapper {
        position: relative;
        display: flex;
        align-items: flex-end;
        gap: .5rem;
        padding: .6rem;
        background: rgba(0,0,0,0.02);
        border: 1px solid var(--bd);
        border-radius: 16px;
      }
      #recordBtn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        background: var(--primary);
        color: var(--primary-contrast);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
      }
      #recordBtn.recording {
        background: #dc2626;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0%   { transform: scale(1); }
        50%  { transform: scale(1.05); }
        100% { transform: scale(1); }
      }
      #pauseBtn {
        display: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--primary);
        color: var(--primary-contrast);
        border: none;
        cursor: pointer;
        font-size: 1rem;
      }
      #sendBtn, #sendTextBtn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        background: var(--primary);
        color: var(--primary-contrast);
        transition: opacity .2s;
      }
      #sendBtn[disabled], #sendTextBtn[disabled] { opacity: .5; cursor: not-allowed; }
      #textInput {
        flex: 1;
        min-height: 24px;
        max-height: 120px;
        resize: none;
        border: none;
        outline: none;
        background: transparent;
        font-size: .95rem;
      }
      #timer {
        position: absolute;
        top: -1.6rem;
        left: 50%;
        transform: translateX(-50%);
        padding: .2rem .6rem;
        background: #dc2626;
        color: #fff;
        border-radius: 999px;
        font-size: .75rem;
        display: none;
      }
      /* Hidden elements used by the script to maintain compatibility */
      #transcript, #answer {
        display: none;
      }
      /* Hide the mobile toggle button by default; it becomes visible on small screens */
      .mobile-toggle { display: none; }
      /* Hide the mobile header by default; it becomes visible on small screens */
      #mobileHeader { display: none; }
      /* Mobile responsiveness: reuse existing classes */
      @media (max-width: 940px) {
        .side {
          position: fixed;
          top: 0;
          left: 0;
          width: 75%;
          height: 100vh;
          z-index: 999;
          background: #fff;
          border-right: 1px solid var(--bd);
          overflow: auto;
          transition: transform .3s ease-out;
          transform: translateX(-100%);
        }
        .side.open { transform: translateX(0); }
        .mobile-toggle {
          display: inline-block;
          margin: .5rem 1rem;
          cursor: pointer;
          background: var(--card);
          border: 1px solid var(--bd);
          padding: .5rem .75rem;
          border-radius: 8px;
        }
        /* Show the mobile header when the viewport is narrow */
        #mobileHeader { display: block; }
      }
    </style>
  </head>
  <body>
    <!-- Authentication bar: displays sign in/out and user details -->
    <div id="authBar">
      <div class="user-info">
        <img id="userPhoto" src="" alt="User" />
        <span id="userName" class="user-name"></span>
        <span id="userEmail" class="user-email"></span>
      </div>
      <div>
        <div class="auth-actions">
  <button id="loginBtn" class="btn-auth btn-google" title="Sign in with Google">
    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="#EA4335" d="M12 10.2v3.7h5.1c-.2 1.2-1.5 3.6-5.1 3.6-3.1 0-5.7-2.6-5.7-5.7S8.9 6 12 6c1.7 0 2.9.7 3.5 1.3l2.4-2.4C16.8 3.6 14.6 2.7 12 2.7 6.9 2.7 2.7 6.9 2.7 12S6.9 21.3 12 21.3c6.1 0 9.1-4.3 9.1-8.6 0-.6-.1-1-.1-1.5H12z"/>
    </svg>
    Sign in with Google
  </button>

  <button id="fbLoginBtn" class="btn-auth btn-facebook" title="Sign in with Facebook">
    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M22 12.07C22 6.48 17.52 2 11.93 2S2 6.48 2 12.07C2 17.08 5.66 21.2 10.44 22v-7.03H7.9V12.1h2.54V9.83c0-2.5 1.49-3.88 3.77-3.88 1.09 0 2.23.2 2.23.2v2.46h-1.26c-1.24 0-1.63.77-1.63 1.56v1.92h2.78l-.44 2.87h-2.34V22C18.34 21.2 22 17.08 22 12.07z"/>
    </svg>
    Sign in with Facebook
  </button>

  <button id="emailLoginBtn" class="btn-auth btn-email" title="Sign in with Email">
    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M20 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2Zm0 4-8 5L4 8V6l8 5 8-5v2Z"/>
    </svg>
    Sign in with Email
  </button>

  <button id="phoneLoginBtn" class="btn-auth btn-phone" title="Sign in with Mobile">
    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M17 1H7a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2Zm-5 21a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/>
    </svg>
    Sign in with Mobile
  </button>

  <button id="logoutBtn" class="btn-auth" style="display:none">üö™ Sign out</button>
</div>

        
      </div>
    </div>
    <div id="loginRequired" style="display:none; text-align:center; margin:1rem 0; padding:1rem; border:1px solid var(--bd); border-radius:12px; background:#fff;">
      Please sign in to start using Kid Speak &amp; Learn.
    </div>
    <!-- Button to reveal recent chats on mobile.  Visible only on small screens -->
    <button id="toggleSidebarBtn" class="mobile-toggle">Recent Chats</button>
    <div class="app-container">
      <!-- Sidebar containing header, language selection, chats and user profile -->
      <aside class="side" id="sidebar">
        <div class="header">
          <div class="logo">
            <div class="logo-icon">üí¨</div>
            <h1>Kid Speak &amp; Learn</h1>
          </div>
          <div id="langCard" class="lang-card">
            <div style="display:flex; align-items:center; gap:.5rem;">
              <span>üåê</span>
              <span id="langLabel">English ‚Üí English</span>
            </div>
            <span style="font-size:.9rem;">‚ñº</span>
          </div>
          <div id="langSettings" class="lang-settings" style="display:none;">
            <div style="margin-bottom:.75rem;">
              <label for="speakLang">Speaking</label>
              <select id="speakLang" required>
                <option value="">Select language</option>
                <option>English</option>
                <option>Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                <option>Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)</option>
                <option>Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)</option>
                <option>Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)</option>
                <option>Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)</option>
                <option>Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)</option>
                <option>Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)</option>
                <option>Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</option>
                <option>Panjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)</option>
              </select>
            </div>
            <div>
              <label for="answerLang">Answer</label>
              <select id="answerLang" required>
                <option value="">Select language</option>
                <option>English</option>
                <option>Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                <option>Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)</option>
                <option>Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)</option>
                <option>Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)</option>
                <option>Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)</option>
                <option>Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)</option>
                <option>Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)</option>
                <option>Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</option>
                <option>Panjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)</option>
              </select>
            </div>
          </div>
        </div>
        <div style="flex:1; overflow-y:auto; padding: 1rem;">
          <div class="chat-list-header">
  <h3 style="font-size:.9rem; font-weight:600; color: var(--muted); margin:0;">Recent Chats</h3>
  <div style="display:flex; gap:.4rem;">
    <button id="newChatBtn" title="New chat" style="background:none; border:none; cursor:pointer; font-size:1.2rem;">‚ûï</button>
    <button id="clearAllBtn" title="Delete all chats" style="background:none; border:none; cursor:pointer; font-size:1.2rem;">üóëÔ∏è</button>
  </div>
</div>

          <div id="chatList" class="chatlist" style="display:flex; flex-direction:column; gap:.5rem;"></div>
        </div>
        <div class="user-profile">
          <div class="avatar" id="userAvatar">üë§</div>
          <div class="info">
            <div class="name" id="profileName"></div>
            <div class="email" id="profileEmail"></div>
          </div>
          <button id="settingsBtn" style="background:none; border:none; cursor:pointer; font-size:1.2rem; color: var(--muted);">‚öôÔ∏è</button>
        </div>
      </aside>
      <!-- Main conversation area -->
      <main>
        <!-- Mobile header shows the app name and language selector on small screens.  Hidden on desktop. -->
        <div id="mobileHeader" class="mobile-header" style="padding:1rem; border-bottom:1px solid var(--bd);">
          <div style="display:flex; align-items:center; gap:.75rem; margin-bottom:.5rem;">
            <div style="width:32px; height:32px; background:var(--primary); color:var(--primary-contrast); border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:.9rem;">üí¨</div>
            <h1 style="margin:0; font-size:1.2rem; font-weight:600;">Kid Speak &amp; Learn</h1>
          </div>
          <!-- Language selector for mobile -->
          <div id="mobileLangCard" class="lang-card" style="margin-bottom:.5rem;">
            <div style="display:flex; align-items:center; gap:.5rem;">
              <span>üåê</span>
              <span id="mobileLangLabel">English ‚Üí English</span>
            </div>
            <span style="font-size:.9rem;">‚ñº</span>
          </div>
          <div id="mobileLangSettings" class="lang-settings" style="display:none;">
            <div style="margin-bottom:.75rem;">
              <label for="mobileSpeakLang">Speaking</label>
              <select id="mobileSpeakLang" required>
                <option value="">Select language</option>
                <option>English</option>
                <option>Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                <option>Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)</option>
                <option>Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)</option>
                <option>Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)</option>
                <option>Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)</option>
                <option>Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)</option>
                <option>Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)</option>
                <option>Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</option>
                <option>Panjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)</option>
              </select>
            </div>
            <div>
              <label for="mobileAnswerLang">Answer</label>
              <select id="mobileAnswerLang" required>
                <option value="">Select language</option>
                <option>English</option>
                <option>Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                <option>Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)</option>
                <option>Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)</option>
                <option>Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)</option>
                <option>Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)</option>
                <option>Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)</option>
                <option>Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)</option>
                <option>Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</option>
                <option>Panjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)</option>
              </select>
            </div>
          </div>
        </div>
        <div id="status" class="status">Choose both languages ‚Üí tap <b>Start recording</b>, type a question or tap <b>Send</b>.</div>
        <div id="loadingBar">We are preparing your answers‚Ä¶</div>
        <!-- Chat thread -->
        <div id="chatThread"></div>
        <!-- Suggestions -->
        <div id="suggestions"></div>
        <!-- Audio player -->
        <audio id="player" controls></audio>
        <!-- Input panel -->
        <div class="input-panel">
          <div class="input-wrapper">
            <button id="recordBtn" title="Start recording">üéôÔ∏è</button>
            <button id="pauseBtn" title="Pause/Resume">‚è∏</button>
            <textarea id="textInput" placeholder="Type your message here‚Ä¶" rows="1"></textarea>
            <button id="sendBtn" title="Send audio" disabled>üì§</button>
            <button id="sendTextBtn" title="Send text" disabled>‚û§</button>
            <span id="timer">00:00</span>
          </div>
          <div id="voiceActions" style="display:none; gap:.5rem; margin-top:.5rem;">
  <button id="voiceSendBtn"  title="Send recording">üì§ Send</button>
  <button id="voiceDiscardBtn" title="Discard recording">üóëÔ∏è Delete</button>
</div>
        </div>
      </main>
    </div>
    <!-- Hidden transcript/answer boxes used by the script -->
    <div id="transcript"></div>
    <div id="answer"></div>
    <!-- Firebase and app scripts -->
    <script type="module">
      // Import Firebase SDKs
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js';
      import {getAuth, GoogleAuthProvider, FacebookAuthProvider,signInWithPopup, signOut, onAuthStateChanged, getIdToken,createUserWithEmailAndPassword, signInWithEmailAndPassword,RecaptchaVerifier, signInWithPhoneNumber} from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js';

      // import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged, getIdToken } from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js';
      import { getFirestore, doc, setDoc, updateDoc, collection, addDoc, serverTimestamp, query, orderBy, limit, getDocs } from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js';
      // Your web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyARKGvFd051nAxe3lXpkcktBHl46NP38A0",
        authDomain: "kid-speak-learn.firebaseapp.com",
        projectId: "kid-speak-learn",
        storageBucket: "kid-speak-learn.firebasestorage.app",
        messagingSenderId: "334841993987",
        appId: "1:334841993987:web:1eebc8a53936d06ed0e736"
      };
      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const provider = new GoogleAuthProvider();
      const fbProvider = new FacebookAuthProvider();
      // DOM references for auth
      const loginBtn    = document.getElementById('loginBtn');
      const logoutBtn   = document.getElementById('logoutBtn');
      const userNameEl  = document.getElementById('userName');
      const userEmailEl = document.getElementById('userEmail');
      const userPhotoEl = document.getElementById('userPhoto');
      const loginReqEl  = document.getElementById('loginRequired');
      const fbLoginBtn = document.getElementById('fbLoginBtn');
fbLoginBtn.addEventListener('click', async () => {
  try { await signInWithPopup(auth, fbProvider); }
  catch (e) { alert('Facebook login failed: ' + (e?.message || e)); }
});

      // Expose to global for non-module script
      window.__auth = { auth, getIdToken, user: null };
      window.__db   = { db, doc, setDoc, updateDoc, collection, addDoc, serverTimestamp, query, orderBy, limit, getDocs };
      // Login click handler
      loginBtn.addEventListener('click', async () => {
        try {
          await signInWithPopup(auth, provider);
        } catch (e) {
          alert('Login failed: ' + (e?.message || e));
        }
      });

      const emailLoginBtn = document.getElementById('emailLoginBtn');
emailLoginBtn.addEventListener('click', async () => {
  const email = prompt('Enter email:');
  const pass  = prompt('Enter password (min 6 chars):');
  if (!email || !pass) return;
  try {
    await signInWithEmailAndPassword(auth, email, pass);
  } catch (e) {
    if (String(e?.code).includes('user-not-found')) {
      try { 
        await createUserWithEmailAndPassword(auth, email, pass); 
      } catch (e2) { 
        alert('Sign up failed: ' + (e2?.message || e2)); 
      }
    } else {
      alert('Email sign-in failed: ' + (e?.message || e));
    }
  }
});
// Phone login needs reCAPTCHA
let appVerifier;
onAuthStateChanged(auth, (u) => {
  if (!appVerifier) {
    appVerifier = new RecaptchaVerifier(auth, 'recaptcha-container', { size: 'invisible' });
  }
});

const phoneLoginBtn = document.getElementById('phoneLoginBtn');
phoneLoginBtn.addEventListener('click', async () => {
  try {
    const phone = prompt('Enter mobile with country code (e.g. +91XXXXXXXXXX):');
    if (!phone) return;
    if (!appVerifier) appVerifier = new RecaptchaVerifier(auth, 'recaptcha-container', { size: 'invisible' });
    const confirmation = await signInWithPhoneNumber(auth, phone, appVerifier);
    const code = prompt('Enter the 6-digit OTP you received:');
    if (!code) return;
    await confirmation.confirm(code);
  } catch (e) {
    alert('Phone sign-in failed: ' + (e?.message || e));
  }
});

      // Logout handler
      logoutBtn.addEventListener('click', async () => {
        try { await signOut(auth); } catch (e) { console.error(e); }
      });
      // Auth state observer
      onAuthStateChanged(auth, async (user) => {
        window.__auth.user = user;
        if (user) {
          // Show user info
          userNameEl.textContent  = user.displayName || '';
          userEmailEl.textContent = user.email || '';
          if (user.photoURL) {
            userPhotoEl.src = user.photoURL;
            userPhotoEl.style.display = '';
          } else {
            userPhotoEl.style.display = 'none';
          }
          loginBtn.style.display  = 'none';
          logoutBtn.style.display = '';
          loginReqEl.style.display = 'none';
          // Populate profile in sidebar
          document.getElementById('profileName').textContent = user.displayName || '';
          document.getElementById('profileEmail').textContent = user.email || '';
          if (user.photoURL) {
            document.getElementById('userAvatar').textContent = '';
            document.getElementById('userAvatar').style.backgroundImage = `url(${user.photoURL})`;
            document.getElementById('userAvatar').style.backgroundSize = 'cover';
            document.getElementById('userAvatar').style.backgroundPosition = 'center';
          }
          // Fetch chats from Firestore and merge into local storage if none
          await syncChatsFromFirestore(user.uid);
          enableAppControls(true);
        } else {
          // Logged out
          userNameEl.textContent  = '';
          userEmailEl.textContent = '';
          userPhotoEl.style.display = 'none';
          loginBtn.style.display  = '';
          logoutBtn.style.display = 'none';
          loginReqEl.style.display = '';
          document.getElementById('profileName').textContent = '';
          document.getElementById('profileEmail').textContent = '';
          document.getElementById('userAvatar').style.backgroundImage = '';
          document.getElementById('userAvatar').textContent = 'üë§';
          enableAppControls(false);
          window.__auth.lastIdToken = null;
        }
      });
      // Toggle the language settings view
      const langCard = document.getElementById('langCard');
      const langSettings = document.getElementById('langSettings');
      const langLabel = document.getElementById('langLabel');
      langCard.addEventListener('click', () => {
        const open = langSettings.style.display !== 'none';
        langSettings.style.display = open ? 'none' : 'block';
      });
      // Update the language label when selections change
      const speakSelect = document.getElementById('speakLang');
      const answerSelect = document.getElementById('answerLang');
      // ---- Language persistence (localStorage) ----
const LANG_KEY = "kid_lang_v1";
function saveLangPrefs() {
  const data = {
    speak: speakSelect.value || "",
    answer: answerSelect.value || ""
  };
  localStorage.setItem(LANG_KEY, JSON.stringify(data));
}
window.loadLangPrefs=function loadLangPrefs() {
  try {
    const data = JSON.parse(localStorage.getItem(LANG_KEY));
    if (!data) return;
    if (data.speak) {
      speakSelect.value = data.speak;
      const mobileSpeakSel = document.getElementById('mobileSpeakLang');
      if (mobileSpeakSel) mobileSpeakSel.value = data.speak;
    }
    if (data.answer) {
      answerSelect.value = data.answer;
      const mobileAnsSel = document.getElementById('mobileAnswerLang');
      if (mobileAnsSel) mobileAnsSel.value = data.answer;
    }
    updateLangLabel();
  } catch {}
}

      window.updateLangLabel =function updateLangLabel() {
        const speak = speakSelect.value || 'Speaking';
        const ans   = answerSelect.value || 'Answer';
        langLabel.textContent = speak + ' ‚Üí ' + ans;
        // Also update the mobile language label if it exists
        const mobileLabel = document.getElementById('mobileLangLabel');
        if (mobileLabel) {
          mobileLabel.textContent = speak + ' ‚Üí ' + ans;
        }
      }
      speakSelect.addEventListener('change', () => {
        // sync mobile select when desktop select changes
        const mobileSpeak = document.getElementById('mobileSpeakLang');
        if (mobileSpeak && mobileSpeak.value !== speakSelect.value) {
          mobileSpeak.value = speakSelect.value;
        }
        updateLangLabel();
        validateLangs();
        saveLangPrefs();
      });
      answerSelect.addEventListener('change', () => {
        // sync mobile select when desktop select changes
        const mobileAnswer = document.getElementById('mobileAnswerLang');
        if (mobileAnswer && mobileAnswer.value !== answerSelect.value) {
          mobileAnswer.value = answerSelect.value;
        }
        updateLangLabel();
        validateLangs();
        saveLangPrefs();
      });

      // Mobile language selector logic
      const mobileLangCard = document.getElementById('mobileLangCard');
      const mobileLangSettings = document.getElementById('mobileLangSettings');
      if (mobileLangCard) {
        mobileLangCard.addEventListener('click', () => {
          const open = mobileLangSettings.style.display !== 'none';
          mobileLangSettings.style.display = open ? 'none' : 'block';
        });
      }
      const mobileSpeak = document.getElementById('mobileSpeakLang');
      const mobileAnswer = document.getElementById('mobileAnswerLang');
      function updateMobileLangLabel() {
        const speak = mobileSpeak.value || 'Speaking';
        const ans   = mobileAnswer.value || 'Answer';
        const mobileLabel = document.getElementById('mobileLangLabel');
        if (mobileLabel) mobileLabel.textContent = speak + ' ‚Üí ' + ans;
      }
      if (mobileSpeak) {
        mobileSpeak.addEventListener('change', () => {
          // sync desktop select when mobile select changes
          if (speakSelect.value !== mobileSpeak.value) {
            speakSelect.value = mobileSpeak.value;
            // update all dependent states
            updateLangLabel();
            validateLangs();
          }
          updateMobileLangLabel();
        });
      }
      if (mobileAnswer) {
        mobileAnswer.addEventListener('change', () => {
          if (answerSelect.value !== mobileAnswer.value) {
            answerSelect.value = mobileAnswer.value;
            updateLangLabel();
            validateLangs();
          }
          updateMobileLangLabel();
        });
      }
    </script>
    <!-- Existing application script preserved for chat functionality -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
<script>
  function renderMD(mdText) {
    const normalized = (mdText || "").replace(/\r\n/g, "\n");
    const html = marked.parse(normalized, { breaks: true, gfm: true });
    return DOMPurify.sanitize(html);
  }
</script>
    <script>
      const API_BASE = "https://elearning-for-kids.onrender.com";
      // ---------- DOM ----------
      const chatList    = document.getElementById('chatList');
      const newChatBtn  = document.getElementById('newChatBtn');
      const recordBtn   = document.getElementById('recordBtn');
      const pauseBtn    = document.getElementById('pauseBtn');
      const sendBtn     = document.getElementById('sendBtn');
      const statusEl    = document.getElementById('status');
      const transcriptEl= document.getElementById('transcript');
      const answerEl    = document.getElementById('answer');
      const player      = document.getElementById('player');
      const speakLangSel= document.getElementById('speakLang');
      const answerLangSel=document.getElementById('answerLang');
      const timerBadge  = document.getElementById('timer');
      const loadingBar  = document.getElementById('loadingBar');
      const textInput   = document.getElementById('textInput');
      const sendTextBtn = document.getElementById('sendTextBtn');
      // ---------- Local storage helpers ----------
      const LS_KEY = "kid_chats_v1";
      function loadAllChats(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)) || []; }catch{ return []; } }
      function saveAllChats(list){ localStorage.setItem(LS_KEY, JSON.stringify(list)); }
      function createChat(){
        const id = crypto.randomUUID();
        const chat = { id, title: "New chat", createdAt: Date.now(), messages: [] };
        const list = loadAllChats(); list.unshift(chat); saveAllChats(list);
        // Firestore: create chat
        const user = window.__auth?.user;
        if (user) createFirestoreChat(user.uid, id, chat.title);
        return chat;
      }
      function getChat(id){ return loadAllChats().find(c=>c.id===id); }
      function updateChat(chat){
        const list = loadAllChats();
        const idx = list.findIndex(c=>c.id===chat.id);
        if (idx>=0){ list[idx]=chat; } else { list.unshift(chat); }
        saveAllChats(list);
      }
      function deleteChat(id) {
  if (!id) return;
  if (!confirm('Delete this chat? This cannot be undone.')) return;

  // 1) local storage removal
  const list = loadAllChats().filter(c => c.id !== id);
  saveAllChats(list);

  // 2) Firestore removal (best-effort)
  const user = window.__auth?.user;
  if (user) {
    deleteFirestoreChat(user.uid, id).catch(e => console.warn('Firestore delete failed:', e));
  }

  // 3) fix current selection
  if (currentChatId === id) {
    if (list.length) {
      currentChatId = list[0].id;
      loadChat(currentChatId);
    } else {
      // No chats left ‚Äî create a fresh one
      const c = createChat();
      loadChat(c.id);
    }
  } else {
    renderChatList();
  }

  // UI status
  statusEl.textContent = 'Chat deleted.';
}
      function deleteAllChats() {
  if (!confirm('Delete ALL chats? This cannot be undone.')) return;

  // local wipe
  saveAllChats([]);

  // Firestore wipe (best-effort)
  const user = window.__auth?.user;
  if (user) {
    // get all chats from Firestore and delete
    (async () => {
      try {
        const { db, collection, getDocs } = window.__db;
        const chatsCol = collection(db, 'users', user.uid, 'chats');
        const snap = await getDocs(chatsCol);
        for (const docSnap of snap.docs) {
          await deleteFirestoreChat(user.uid, docSnap.id);
        }
      } catch (e) {
        console.warn('Firestore clear all failed:', e);
      }
    })();
  }

  // reset UI
  const c = createChat();
  loadChat(c.id);
  statusEl.textContent = 'All chats cleared.';
}


      function setTitleIfEmpty(chat, firstUserText){
        if (!firstUserText) return;
        if (chat.title==="New chat" || !chat.title){
          chat.title = firstUserText.slice(0, 40) + (firstUserText.length>40 ? "‚Ä¶" : "");
        }
      }
      // Firestore helpers
      async function createFirestoreChat(uid, chatId, title){
        const { db, doc, setDoc, serverTimestamp } = window.__db;
        try {
          const chatRef = doc(db, 'users', uid, 'chats', chatId);
          await setDoc(chatRef, { title, createdAt: serverTimestamp(), updatedAt: serverTimestamp(), lastSnippet: '' }, { merge:true });
        } catch (e) { console.error('Failed to create chat in Firestore', e); }
      }
      async function saveTurnToFirestore(uid, chatId, userText, assistantText, speakLang, answerLang){
        const { db, collection, addDoc, serverTimestamp, doc, updateDoc } = window.__db;
        try {
          const msgsCol = collection(db, 'users', uid, 'chats', chatId, 'messages');
          if (userText) {
            await addDoc(msgsCol, {
              role: 'user',
              content: userText,
              speakLanguage: speakLang,
              answerLanguage: answerLang,
              createdAt: serverTimestamp()
            });
          }
          if (assistantText) {
            await addDoc(msgsCol, {
              role: 'assistant',
              content: assistantText,
              speakLanguage: speakLang,
              answerLanguage: answerLang,
              createdAt: serverTimestamp()
            });
            // update chat metadata
            const chatRef = doc(db, 'users', uid, 'chats', chatId);
            await updateDoc(chatRef, {
              updatedAt: serverTimestamp(),
              lastSnippet: assistantText.slice(0,120)
            });
          }
        } catch (e) { console.error('Failed to save turn to Firestore', e); }
      }
      async function deleteFirestoreChat(uid, chatId) {
  const { db, collection, getDocs, doc } = window.__db;
  // Delete subcollection messages in small batches
  const msgsCol = collection(db, 'users', uid, 'chats', chatId, 'messages');
  const snap = await getDocs(msgsCol);
  const batchDeletes = [];
  snap.forEach(m => batchDeletes.push(m.ref.delete ? m.ref.delete() : null));
  await Promise.all(batchDeletes);

  // Delete chat doc itself
  const chatRef = doc(db, 'users', uid, 'chats', chatId);
  try { await (await import('https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js')).deleteDoc(chatRef); }
  catch (e) {
    // Older SDK import pattern fallback
    const { deleteDoc } = window.__db;
    await deleteDoc(chatRef);
  }
}

      // ---------- UI: render chat list ----------
      let currentChatId = null;
      function renderChatList(){
        const list = loadAllChats();
        chatList.innerHTML = "";
        list.forEach(chat=>{
          const div = document.createElement("div");
          div.className = "chatitem" + (chat.id===currentChatId ? " active":"");
          const d = new Date(chat.createdAt);
          const when = d.toLocaleDateString() + " " + d.toLocaleTimeString();
          div.innerHTML = `
  <div style="display:flex; align-items:center; justify-content:space-between; gap:.5rem;">
    <div>
      <div style="font-weight:600">${chat.title}</div>
      <div style="font-size:.85rem;color:#666">${when}</div>
    </div>
    <button class="chat-del" title="Delete this chat" style="background:none;border:none;cursor:pointer;font-size:1.1rem;">üóëÔ∏è</button>
  </div>
`;
          div.onclick = () => loadChat(chat.id);
    const delBtn = div.querySelector('.chat-del');
    delBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      deleteChat(chat.id);
    });


          chatList.appendChild(div);
        });
      }
      function loadChat(id){
        currentChatId = id;
        renderChatList();
        const chat = getChat(id);
        // Show last turn in the simple boxes
        if (chat && chat.messages.length){
          const lastUser = [...chat.messages].reverse().find(m=>m.role==="user");
          const lastAsst = [...chat.messages].reverse().find(m=>m.role==="assistant");
          transcriptEl.textContent = lastUser?.content || "‚Äî";
          answerEl.textContent = lastAsst?.content || "‚Äî";
        } else {
          transcriptEl.textContent = "‚Äî";
          answerEl.textContent = "‚Äî";
        }
        player.removeAttribute("src"); player.load();
        loadingBar.style.display = "none";
        statusEl.textContent = "Loaded chat. Record a follow-up, type a question or start a New chat.";
        lastBlob = null;
        validateLangs();
        // Render the full message thread
        renderThread();
      }
      // Boot: ensure at least one chat exists
      (function initChats(){
        const all = loadAllChats();
        if (all.length===0){
          const c = createChat();
          currentChatId = c.id;
        } else {
          currentChatId = all[0].id;
        }
        renderChatList();
      })();
      newChatBtn.addEventListener('click', ()=>{
        const c = createChat();
        loadChat(c.id);
      });
      const clearAllBtn = document.getElementById('clearAllBtn');
clearAllBtn.addEventListener('click', deleteAllChats);

      // ---------- Recording (same as before with Pause/Resume) ----------
      let mediaRecorder, chunks = [], isRecording = false, startTs = 0, tickInt = null, lastBlob = null;
      function validateLangs() {
        const ok = speakLangSel.value && answerLangSel.value;
        recordBtn.disabled = !ok || !window.__auth?.user;
        sendBtn.disabled   = !ok || !lastBlob || !window.__auth?.user;
        sendTextBtn.disabled = !ok || !window.__auth?.user || !textInput.value.trim();
        return ok;
      }
      speakLangSel.addEventListener('change', validateLangs);
      answerLangSel.addEventListener('change', validateLangs);
      textInput.addEventListener('input', validateLangs);
      async function getStream() {
        try { return await navigator.mediaDevices.getUserMedia({ audio: true }); }
        catch { alert("Microphone permission is required."); throw new Error("no-mic"); }
      }
      function fmt(sec){const m=String(Math.floor(sec/60)).padStart(2,'0');const s=String(Math.floor(sec%60)).padStart(2,'0');return `${m}:${s}`;}
      function startTimer(){timerBadge.style.display='inline-block';startTs=Date.now();tickInt=setInterval(()=>{timerBadge.textContent=fmt((Date.now()-startTs)/1000);},250);}
      function stopTimer(){clearInterval(tickInt);tickInt=null; timerBadge.style.display='none';}
      async function toggleRecording() {
        // Only allow recording if logged in
        if (!window.__auth?.user) { statusEl.textContent = "Please sign in first."; return; }
        if (!validateLangs()) { statusEl.textContent = "Please select both languages first."; return; }
        if (!isRecording) {
          statusEl.textContent = 'Recording‚Ä¶';
          const stream = await getStream();
          chunks = [];
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
          mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            lastBlob = blob;
            if (blob.size < 5000) {
  statusEl.textContent = 'Too short. Record at least 1 second.';
  sendBtn.disabled = true;
  voiceActions.style.display = 'none';   // <--- HIDE actions
} else {
  statusEl.textContent = 'Recording saved. Tap Send or Delete.';
  sendBtn.disabled = !validateLangs();
  voiceActions.style.display = 'flex';   // <--- SHOW actions
}

          };
          mediaRecorder.start();
          isRecording = true;
          recordBtn.textContent = "‚èπ";
          recordBtn.classList.add('recording');
          pauseBtn.style.display = 'inline-flex'; pauseBtn.disabled = false; pauseBtn.textContent = "‚è∏";
          startTimer();
        } else {
          stopTimer();
          statusEl.textContent = 'Processing recording‚Ä¶';
          isRecording = false;
          recordBtn.textContent = "üéôÔ∏è";
          recordBtn.classList.remove('recording');
          pauseBtn.style.display = 'none'; pauseBtn.disabled = true;
          try { mediaRecorder.stop(); } catch {}
        }
      }
      recordBtn.addEventListener('click', toggleRecording);
      // --- Long-press recording (WhatsApp style) ---
let pressTimer = null;
let didStartByLongPress = false;

function startRecordingNow() {
  didStartByLongPress = true;
  if (!isRecording) toggleRecording();
}
function stopRecordingNow() {
  if (isRecording) toggleRecording();
}
function handlePressStart(e) {
  if (!window.__auth?.user) { statusEl.textContent = "Please sign in first."; return; }
  if (!validateLangs()) { statusEl.textContent = "Please select both languages."; return; }
  e.preventDefault();
  didStartByLongPress = false;
  pressTimer = setTimeout(startRecordingNow, 300);
}
function handlePressEnd(e) {
  e.preventDefault();
  clearTimeout(pressTimer); pressTimer = null;
  if (didStartByLongPress) {
    stopRecordingNow();
  }
}
function handlePressCancel() {
  clearTimeout(pressTimer); pressTimer = null;
}

// Desktop + Mobile
recordBtn.addEventListener('mousedown', handlePressStart);
recordBtn.addEventListener('mouseup', handlePressEnd);
recordBtn.addEventListener('mouseleave', handlePressCancel);
recordBtn.addEventListener('touchstart', handlePressStart, { passive:false });
recordBtn.addEventListener('touchend', handlePressEnd);
recordBtn.addEventListener('touchcancel', handlePressCancel);

// Voice action buttons
const voiceActions = document.getElementById('voiceActions');
const voiceSendBtn = document.getElementById('voiceSendBtn');
const voiceDiscardBtn = document.getElementById('voiceDiscardBtn');

voiceSendBtn.addEventListener('click', async () => {
  await sendAudio();
  voiceActions.style.display = 'none';
});
voiceDiscardBtn.addEventListener('click', () => {
  lastBlob = null;
  sendBtn.disabled = true;
  statusEl.textContent = 'Recording discarded.';
  voiceActions.style.display = 'none';
});

      pauseBtn.addEventListener('click', () => {
        if (!mediaRecorder) return;
        if (mediaRecorder.state === 'recording') {
          mediaRecorder.pause();
          pauseBtn.textContent = "‚ñ∂Ô∏è";
          statusEl.textContent = 'Paused. Resume or Stop.';
        } else if (mediaRecorder.state === 'paused') {
          mediaRecorder.resume();
          pauseBtn.textContent = "‚è∏";
          statusEl.textContent = 'Recording‚Ä¶';
        }
      });
      // ---------- Send to server with history ----------
      function getHistoryForCurrentChat(limitTurns=6){
        const chat = getChat(currentChatId);
        if (!chat) return [];
        const msgs = chat.messages || [];
        return msgs.slice(-limitTurns*2); // last N user/assistant pairs
      }
      function appendTurnToChat(userText, assistantText){
        const chat = getChat(currentChatId);
        if (!chat) return;
        if (userText)  chat.messages.push({ role:"user",      content:userText });
        if (assistantText) chat.messages.push({ role:"assistant", content:assistantText });
        setTitleIfEmpty(chat, userText);
        updateChat(chat);
        renderChatList();
        // Firestore
        const user = window.__auth?.user;
        if (user) saveTurnToFirestore(user.uid, chat.id, userText, assistantText, speakLangSel.value, answerLangSel.value);
        // Update visible thread
        renderThread();
      }
      async function getAuthHeader() {
        const user = window.__auth?.user;
        if (!user) return {};
        try {
          const token = await window.__auth.getIdToken(user, /*forceRefresh*/ false);
          return { 'Authorization': 'Bearer ' + token };
        } catch {
          return {};
        }
      }
      async function readSSEStream(res, onToken) {
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });

    // Split on double newlines (SSE event separation)
    let parts = buffer.split("\n\n");
    buffer = parts.pop(); // last (maybe partial) chunk kept in buffer

    for (const chunk of parts) {
      // Each line typically starts with "data: "
      const lines = chunk.split("\n").map(l => l.replace(/^data:\s?/, ""));
      const data = lines.join("\n");

      if (data === "[END]") return;      // server‚Äôs end marker
      if (data) onToken(data);            // incremental token
    }
  }
}

      // async function sendAudio() {
      //   if (!window.__auth?.user) { statusEl.textContent = "Please sign in first."; return; }
      //   if (!lastBlob) { statusEl.textContent = "Please record something first."; return; }
      //   if (!validateLangs()) { statusEl.textContent = "Please select both languages."; return; }
      //   // Hide previous audio player
      //   player.style.display = 'none';
      //   loadingBar.style.display = 'block';
      //   statusEl.textContent = "";
      //   const fd = new FormData();
      //   fd.append('audio', lastBlob, 'speech.webm');
      //   fd.append('speakLanguage',  speakLangSel.value);
      //   fd.append('answerLanguage', answerLangSel.value);
      //   fd.append('conversationId', currentChatId);
      //   fd.append('history', JSON.stringify(getHistoryForCurrentChat(6)));
      //   fd.append('uid', window.__auth.user.uid);
      //   try {
      //     const headers = await getAuthHeader();
      //     const res = await fetch(`${API_BASE}/api/ask`, { method: 'POST', body: fd, headers });
      //     const json = await res.json();
      //     if (!res.ok) {
      //       loadingBar.style.display = 'none';
      //       statusEl.textContent = json?.message || json?.error || 'Request failed';
      //       return;
      //     }
      //     const { transcript, text, audioBase64 } = json;
      //     appendTurnToChat(transcript || "", text || "");
      //     // update transcript/answer (not visible but for reference)
      //     transcriptEl.textContent = transcript || '‚Äî';
      //     answerEl.textContent     = text || '‚Äî';
      //     if (audioBase64) {
      //       player.src = 'data:audio/mpeg;base64,' + audioBase64;
      //       player.style.display = 'block';
      //     } else {
      //       player.removeAttribute('src');
      //       player.style.display = 'none';
      //     }
      //     loadingBar.style.display = 'none';
      //     // Show suggestions for next prompt
      //     updateSuggestions();
      //     statusEl.textContent = 'Done! Ask a follow-up or switch chats.';
      //     lastBlob = null;
      //     recordBtn.textContent = "üéôÔ∏è";
      //     recordBtn.classList.remove('recording');
      //     sendBtn.disabled = true;
      //     pauseBtn.style.display = 'none'; pauseBtn.disabled = true;
      //   } catch (e) {
      //     console.error(e);
      //     loadingBar.style.display = 'none';
      //     statusEl.textContent = "Network error. Try again.";
      //   }
      // }
      async function sendAudio() {
  if (!window.__auth?.user) { statusEl.textContent = "Please sign in first."; return; }
  if (!lastBlob) { statusEl.textContent = "Please record something first."; return; }
  if (!validateLangs()) { statusEl.textContent = "Please select both languages."; return; }

  player.style.display = 'none';
  loadingBar.style.display = 'block';
  statusEl.textContent = "";

  // Create a pending user bubble that we will replace with the transcript
const threadEl = document.getElementById('chatThread');
const userBubble = document.createElement('div');
userBubble.className = 'msg user';
userBubble.textContent = 'üé§ (processing transcript‚Ä¶)';
threadEl.appendChild(userBubble);
threadEl.scrollTop = threadEl.scrollHeight;

  const fd = new FormData();
  fd.append('audio', lastBlob, 'speech.webm');
  fd.append('speakLanguage',  speakLangSel.value);
  fd.append('answerLanguage', answerLangSel.value);
  fd.append('conversationId', currentChatId);
  fd.append('history', JSON.stringify(getHistoryForCurrentChat(6)));
  fd.append('uid', window.__auth.user.uid);

  try {
    const headers = await getAuthHeader();
    const res = await fetch(`${API_BASE}/api/ask`, {
      method: 'POST',
      headers: { ...headers, 'Accept': 'text/event-stream' }, // request SSE
      body: fd
    });

    // Create a live assistant bubble to stream into
    const bubble = createStreamingAssistantBubble();
    let assistantFull = '';
    let transcriptShown = false;

    await readSSEStream(res, (evt) => {
      switch (evt.type) {
        case 'delta': {
          const d = evt.delta || '';
          assistantFull += d;
          appendDelta(bubble, d);
          statusEl.textContent = 'Thinking‚Ä¶';
          break;
        }
        case 'message_end':
          // text finished; TTS may still arrive
          break;
        case 'tts':
          if (evt.audioBase64) {
            player.src = 'data:audio/mpeg;base64,' + evt.audioBase64;
            player.style.display = 'block';
            player.play().catch(err => console.warn("Autoplay blocked:", err));
          }
          break;
        case 'done': {
  userTranscript = (evt.transcript || '(voice message)').trim();

  // 1) Replace the pending user bubble with real transcript
  userBubble.textContent = userTranscript;

  // 2) Update hidden transcript/answer boxes
  transcriptEl.textContent = userTranscript;
  answerEl.textContent = assistantFull;

  // 3) Save both user + assistant turns (user first, then assistant)
  appendTurnToChat(userTranscript, assistantFull);

  // 4) Final UI cleanup
  loadingBar.style.display = 'none';
  updateSuggestions(evt.suggestions || []);
  statusEl.textContent = 'Done! Ask a follow-up or switch chats.';
  lastBlob = null;
  recordBtn.textContent = "üéôÔ∏è";
  recordBtn.classList.remove('recording');
  sendBtn.disabled = true;
  pauseBtn.style.display = 'none'; pauseBtn.disabled = true;
  break;
}

        case 'error':
          throw new Error(evt.message || 'Stream error');
      }
    });

  } catch (e) {
    console.error(e);
    loadingBar.style.display = 'none';
    statusEl.textContent = "Network error. Try again.";
  }
}

      sendBtn.addEventListener('click', sendAudio);

    
// --- Make a live ‚Äúassistant‚Äù bubble and auto-scroll as it grows ---
function createStreamingAssistantBubble() {
  const threadEl = document.getElementById('chatThread');
  const div = document.createElement('div');
  div.className = 'msg assistant';
  // we'll keep a buffer and render markdown as it grows
  div.__mdBuffer = '';
  div.innerHTML = '';
  threadEl.appendChild(div);
  // auto-scroll while content grows
  const observer = new MutationObserver(() => {
    threadEl.scrollTop = threadEl.scrollHeight;
  });
  observer.observe(div, { childList: true, characterData: true, subtree: true });
  return { el: div, observer };
}

function appendDelta(bubble, delta) {
  bubble.el.__mdBuffer += (delta || '');
  // Throttle a bit to avoid re-rendering every single token
  if (bubble.__raf) cancelAnimationFrame(bubble.__raf);
  bubble.__raf = requestAnimationFrame(() => {
    bubble.el.innerHTML = renderMD(bubble.el.__mdBuffer);
  });
}


// --- Generic SSE reader that supports JSON events and raw-token streams ---
// --- Generic SSE reader that supports JSON events and raw-token streams ---
async function readSSEStream(res, onEvent) {
  if (!res || !res.body) throw new Error('No response body to read');
  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buf = '';

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    buf += decoder.decode(value, { stream: true });

    // Split by double newline per SSE framing
    const frames = buf.split('\n\n');
    buf = frames.pop() || '';

    for (const frame of frames) {
      // Expect lines beginning with "data: "
      const lines = frame.split('\n')
        .map(l => l.replace(/^data:\s?/, ''))
        .filter(Boolean);

      for (const line of lines) {
        // Try JSON first (our server sends {type,...})
        let evt = null;
        try { evt = JSON.parse(line); } catch { /* not JSON */ }
        if (evt) { onEvent(evt); continue; }

        // Fallback: treat as raw token stream
        onEvent({ type: 'delta', delta: line });
      }
    }
  }
}

      // ---------- Typed text send ----------
      // 

async function sendText() {
  if (!window.__auth?.user) { statusEl.textContent = "Please sign in first."; return; }
  const textVal = textInput.value.trim();
  if (!textVal) { statusEl.textContent = "Please type something first."; return; }
  if (!validateLangs()) { statusEl.textContent = "Please select both languages."; return; }

  // UI prep
  textInput.value = "";
  player.style.display = 'none';
  loadingBar.style.display = 'block';
  statusEl.textContent = "";

  // Immediately show the user's bubble in the thread
  appendTurnToChat(textVal, null);

  // Create a live assistant bubble to stream into
  const bubble = createStreamingAssistantBubble();

  const body = {
    text: textVal,
    speakLanguage: speakLangSel.value,
    answerLanguage: answerLangSel.value,
    conversationId: currentChatId,
    history: getHistoryForCurrentChat(6),
    uid: window.__auth.user.uid
  };

  try {
    const headers = Object.assign(
      { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' }, // tells server to stream
      await getAuthHeader()
    );

    const res = await fetch(`${API_BASE}/api/ask`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      loadingBar.style.display = 'none';
      let msg = 'Request failed';
      try { msg = (await res.json())?.message || msg; } catch {}
      statusEl.textContent = msg;
      return;
    }

    let assistantFull = '';

    await readSSEStream(res, (evt) => {
      switch (evt.type) {
        case 'delta': {
          const d = evt.delta || '';
          assistantFull += d;
          appendDelta(bubble, d);
          statusEl.textContent = 'Thinking‚Ä¶';
          break;
        }
        case 'message_end':
          // text finished (server may still send TTS next)
          break;
        case 'tts':
          if (evt.audioBase64) {
            player.src = 'data:audio/mpeg;base64,' + evt.audioBase64;
            player.style.display = 'block';
          }
          break;
        case 'warn':
          console.warn('[server warn]', evt.message);
          break;
        case 'done': {
          // finalize: save the assistant turn to storage/Firestore and update UI
          appendTurnToChat(null, assistantFull);
          transcriptEl.textContent = textVal;
          answerEl.textContent     = assistantFull;
          loadingBar.style.display = 'none';
          updateSuggestions(evt.suggestions || []);
          statusEl.textContent = 'Done! Ask a follow-up or switch chats.';
          textInput.value = '';
          validateLangs();
          break;
        }
        case 'error':
          throw new Error(evt.message || 'Stream error');
        default:
          // unknown event; ignore
          break;
      }
    });

  } catch (e) {
    console.error(e);
    loadingBar.style.display = 'none';
    statusEl.textContent = "Network error. Try again.";
  }
}


      sendTextBtn.addEventListener('click', sendText);
      textInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendText();
        }
      });
      // Render the message thread for current chat
      function renderThread() {
        const threadEl = document.getElementById('chatThread');
        threadEl.innerHTML = '';
        const chat = getChat(currentChatId);
        if (!chat || !chat.messages || !chat.messages.length) {
          return;
        }
        chat.messages.forEach(msg => {
  const div = document.createElement('div');
  const isAssistant = msg.role !== 'user';
  div.className = 'msg ' + (isAssistant ? 'assistant' : 'user');

  if (isAssistant) {
    // assistant: render Markdown
    div.innerHTML = renderMD(msg.content || "");
  } else {
    // user: keep plain text (or use renderMD if you also want formatting)
    div.textContent = msg.content || "";
  }
  threadEl.appendChild(div);
});

        // Scroll to bottom
        setTimeout(() => { threadEl.scrollTop = threadEl.scrollHeight; }, 0);
      }
      // Update suggestions with static example prompts
      // Update suggestions with server-provided prompts (fallback to defaults)
function updateSuggestions(suggestions = []) {
  const suggestionsEl = document.getElementById('suggestions');
  const prompts = (Array.isArray(suggestions) && suggestions.length)
    ? suggestions
    : [
        'Can you give me another example?',
        'Could you explain this in simpler words?',
        'What else should I know about this topic?'
      ];

  suggestionsEl.innerHTML = '';
  prompts.forEach(p => {
    const btn = document.createElement('button');
    btn.className = 'suggestion-btn';
    btn.textContent = p;
    btn.addEventListener('click', () => {
      textInput.value = p;
      sendText();
    });
    suggestionsEl.appendChild(btn);
  });
  suggestionsEl.style.display = 'flex';
}

      // Toggle sidebar on mobile
      const toggleBtn = document.getElementById('toggleSidebarBtn');
      const sidebar  = document.getElementById('sidebar');
      toggleBtn.addEventListener('click', () => {
        const open = sidebar.classList.contains('open');
        if (open) {
          sidebar.classList.remove('open');
          document.body.style.overflow = '';
        } else {
          sidebar.classList.add('open');
          document.body.style.overflow = 'hidden';
        }
      });
      // On boot load first chat (if exists) after auth loaded
      window.addEventListener('load', () => {
        loadLangPrefs();
        const all = loadAllChats();
        if (all.length > 0) loadChat(all[0].id);
        validateLangs();
        renderThread();
        updateLangLabel();
        // Synchronise the mobile language selects with the initial desktop values
        const mSpeak = document.getElementById('mobileSpeakLang');
        const mAns   = document.getElementById('mobileAnswerLang');
        if (mSpeak) mSpeak.value = speakLangSel.value;
        if (mAns)   mAns.value   = answerLangSel.value;
        const mobileLabel = document.getElementById('mobileLangLabel');
        if (mobileLabel) mobileLabel.textContent = (speakLangSel.value || 'Speaking') + ' ‚Üí ' + (answerLangSel.value || 'Answer');
      });
    </script>
    <div id="recaptcha-container"></div>

  </body>
</html>
